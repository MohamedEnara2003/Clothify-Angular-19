{
  "version": 3,
  "sources": ["../../../../../../node_modules/projects/ngx-translate/src/lib/extraction-marker.ts", "../../../../../../node_modules/projects/ngx-translate/src/lib/missing-translation-handler.ts", "../../../../../../node_modules/projects/ngx-translate/src/lib/translate.compiler.ts", "../../../../../../node_modules/projects/ngx-translate/src/lib/translate.loader.ts", "../../../../../../node_modules/projects/ngx-translate/src/lib/util.ts", "../../../../../../node_modules/projects/ngx-translate/src/lib/translate.parser.ts", "../../../../../../node_modules/projects/ngx-translate/src/lib/translate.store.ts", "../../../../../../node_modules/projects/ngx-translate/src/lib/translate.service.ts", "../../../../../../node_modules/projects/ngx-translate/src/lib/translate.directive.ts", "../../../../../../node_modules/projects/ngx-translate/src/lib/translate.pipe.ts", "../../../../../../node_modules/projects/ngx-translate/src/lib/translate.providers.ts", "../../../../../../node_modules/projects/ngx-translate/src/lib/translate.module.ts", "../../../../../../node_modules/projects/ngx-translate/src/ngx-translate-core.ts"],
  "sourcesContent": ["export function _<T extends string | string[]>(key: T): T {\n    return key;\n}\n", "import { Injectable } from \"@angular/core\";\nimport { Observable } from \"rxjs\";\nimport { TranslateService, StrictTranslation } from \"./translate.service\";\n\nexport interface MissingTranslationHandlerParams {\n    /**\n     * the key that's missing in translation files\n     */\n    key: string;\n\n    /**\n     * an instance of the service that was unable to translate the key.\n     */\n    translateService: TranslateService;\n\n    /**\n     * interpolation params that were passed along for translating the given key.\n     */\n    interpolateParams?: object;\n}\n\nexport abstract class MissingTranslationHandler {\n    /**\n     * A function that handles missing translations.\n     *\n     * @param params context for resolving a missing translation\n     * @returns a value or an observable\n     *\n     * If it returns a value, then this value is used.\n     * If it returns an observable, the value returned by this observable will be used (except if the method was \"instant\").\n     * If it returns undefined, the key will be used as a value\n     */\n    abstract handle(\n        params: MissingTranslationHandlerParams,\n    ): StrictTranslation | Observable<StrictTranslation>;\n}\n\n/**\n * This handler is just a placeholder that does nothing; in case you don't need a missing translation handler at all\n */\n@Injectable()\nexport class DefaultMissingTranslationHandler implements MissingTranslationHandler {\n    handle(params: MissingTranslationHandlerParams): string {\n        return params.key;\n    }\n}\n", "import { Injectable } from \"@angular/core\";\nimport { InterpolateFunction } from \"./translate.parser\";\nimport {\n    InterpolatableTranslation,\n    InterpolatableTranslationObject,\n    TranslationObject,\n} from \"./translate.service\";\n\nexport abstract class TranslateCompiler {\n    abstract compile(value: string, lang: string): InterpolatableTranslation;\n\n    abstract compileTranslations(\n        translations: TranslationObject,\n        lang: string,\n    ): InterpolatableTranslationObject;\n}\n\n/**\n * This compiler is just a placeholder that does nothing; in case you don't need a compiler at all\n */\n@Injectable()\nexport class TranslateNoOpCompiler extends TranslateCompiler {\n    compile(value: string, lang: string): string | InterpolateFunction {\n        void lang;\n        return value;\n    }\n\n    compileTranslations(\n        translations: TranslationObject,\n        lang: string,\n    ): InterpolatableTranslationObject {\n        void lang;\n        return translations;\n    }\n}\n", "import { Injectable } from \"@angular/core\";\nimport { Observable, of } from \"rxjs\";\nimport { TranslationObject } from \"./translate.service\";\n\nexport abstract class TranslateLoader {\n    abstract getTranslation(lang: string): Observable<TranslationObject>;\n}\n\n/**\n * This loader is just a placeholder that does nothing; in case you don't need a loader at all\n */\n@Injectable()\nexport class TranslateNoOpLoader extends TranslateLoader {\n    getTranslation(lang: string): Observable<TranslationObject> {\n        void lang;\n        return of({});\n    }\n}\n", "import { InterpolatableTranslationObject } from \"./translate.service\";\n\n/**\n * Determines if two objects or two values are equivalent.\n *\n * Two objects or values are considered equivalent if at least one of the following is true:\n *\n * * Both objects or values pass `===` comparison.\n * * Both objects or values are of the same type and all of their properties are equal by\n *   comparing them with `equals`.\n *\n * @param o1 Object or value to compare.\n * @param o2 Object or value to compare.\n * @returns true if arguments are equal.\n */\nexport function equals(o1: unknown, o2: unknown): boolean {\n    if (o1 === o2) return true;\n    if (o1 === null || o2 === null) return false;\n    if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN\n\n    const t1 = typeof o1,\n        t2 = typeof o2;\n    let length: number;\n\n    if (t1 == t2 && t1 == \"object\") {\n        if (Array.isArray(o1)) {\n            if (!Array.isArray(o2)) return false;\n            if ((length = o1.length) == o2.length) {\n                for (let key = 0; key < length; key++) {\n                    if (!equals(o1[key], o2[key])) return false;\n                }\n                return true;\n            }\n        } else {\n            if (Array.isArray(o2)) {\n                return false;\n            }\n            if (isDict(o1) && isDict(o2)) {\n                const keySet = Object.create(null);\n                for (const key in o1) {\n                    if (!equals(o1[key], o2[key])) {\n                        return false;\n                    }\n                    keySet[key] = true;\n                }\n                for (const key in o2) {\n                    if (!(key in keySet) && typeof o2[key] !== \"undefined\") {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nexport function isDefinedAndNotNull<T>(value: T | null | undefined): value is T {\n    return typeof value !== \"undefined\" && value !== null;\n}\n\nexport function isDefined<T>(value: T | null | undefined): value is T | null {\n    return value !== undefined;\n}\n\nexport function isDict(value: unknown): value is InterpolatableTranslationObject {\n    return isObject(value) && !isArray(value) && value !== null;\n}\n\nexport function isObject(value: unknown): value is Record<string, unknown> {\n    return typeof value === \"object\" && value !== null;\n}\n\nexport function isArray(value: unknown): value is unknown[] {\n    return Array.isArray(value);\n}\n\nexport function isString(value: unknown): value is string {\n    return typeof value === \"string\";\n}\n\nexport function isFunction(value: unknown): boolean {\n    return typeof value === \"function\";\n}\n\nfunction cloneDeep(value: unknown): unknown {\n    if (isArray(value)) {\n        return value.map((item) => cloneDeep(item));\n    } else if (isDict(value)) {\n        const cloned: Record<string, unknown> = {};\n        Object.keys(value).forEach((key) => {\n            cloned[key] = cloneDeep((value as Record<string, unknown>)[key]);\n        });\n        return cloned;\n    } else {\n        return value;\n    }\n}\n\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nexport function mergeDeep(target: Readonly<unknown>, source: Readonly<unknown>): any {\n    if (!isObject(target)) {\n        return cloneDeep(source);\n    }\n\n    const output = cloneDeep(target);\n\n    if (isObject(output) && isObject(source)) {\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        Object.keys(source).forEach((key: any) => {\n            if (isDict(source[key])) {\n                if (key in target) {\n                    output[key] = mergeDeep(target[key] as Readonly<unknown>, source[key]);\n                } else {\n                    Object.assign(output, { [key]: source[key] });\n                }\n            } else {\n                Object.assign(output, { [key]: source[key] });\n            }\n        });\n    }\n    return output;\n}\n\n/**\n * Retrieves a value from a nested object using a dot-separated key path.\n *\n * Example usage:\n * ```ts\n * getValue({ key1: { keyA: 'valueI' }}, 'key1.keyA'); // returns 'valueI'\n * ```\n *\n * @param target The source object from which to retrieve the value.\n * @param key Dot-separated key path specifying the value to retrieve.\n * @returns The value at the specified key path, or `undefined` if not found.\n */\nexport function getValue(target: unknown, key: string): unknown {\n    const keys = key.split(\".\");\n\n    key = \"\";\n    do {\n        key += keys.shift();\n        const isLastKey = !keys.length;\n\n        if (isDefinedAndNotNull(target)) {\n            if (\n                isDict(target) &&\n                isDefined(target[key]) &&\n                (isDict(target[key]) || isArray(target[key]) || isLastKey)\n            ) {\n                target = target[key];\n                key = \"\";\n                continue;\n            }\n\n            if (isArray(target)) {\n                const index = parseInt(key, 10);\n                if (\n                    isDefined(target[index]) &&\n                    (isDict(target[index]) || isArray(target[index]) || isLastKey)\n                ) {\n                    target = target[index];\n                    key = \"\";\n                    continue;\n                }\n            }\n        }\n\n        if (isLastKey) {\n            target = undefined;\n            continue;\n        }\n        key += \".\";\n    } while (keys.length);\n\n    return target;\n}\n\n/**\n * Sets a value on object using a dot separated key.\n * This function modifies the object in place\n * parser.setValue({a:{b:{c: \"test\"}}}, 'a.b.c', \"test2\") ==> {a:{b:{c: \"test2\"}}}\n * @param target an object\n * @param key E.g. \"a.b.c\"\n * @param value to set\n * @deprecated use insertValue() instead\n */\nexport function setValue(target: Record<string, unknown>, key: string, value: unknown): void {\n    const keys: string[] = key.split(\".\");\n    let current: Record<string, unknown> = target;\n\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (i === keys.length - 1) {\n            current[key] = value;\n        } else {\n            current = current[key] && isDict(current[key]) ? current[key] : {};\n        }\n    }\n}\n\n/**\n * Sets a value on object using a dot separated key.\n * Returns a clone of the object without modifying it\n * parser.setValue({a:{b:{c: \"test\"}}}, 'a.b.c', \"test2\") ==> {a:{b:{c: \"test2\"}}}\n * @param target an object\n * @param key E.g. \"a.b.c\"\n * @param value to set\n */\nexport function insertValue<T>(target: Readonly<T>, key: string, value: unknown): T {\n    return mergeDeep(target, createNestedObject(key, value) as Readonly<unknown>);\n}\n\nfunction createNestedObject(\n    dotSeparatedKey: string,\n    value: unknown,\n): Record<string, unknown> | unknown {\n    return dotSeparatedKey.split(\".\").reduceRight<unknown>((acc, key) => ({ [key]: acc }), value);\n}\n", "import { Injectable } from \"@angular/core\";\nimport { InterpolationParameters } from \"./translate.service\";\nimport { getValue, isString, isFunction, isArray, isObject } from \"./util\";\n\nexport type InterpolateFunction = (params?: InterpolationParameters) => string;\n\nexport abstract class TranslateParser {\n    /**\n     * Interpolates a string to replace parameters\n     * \"This is a {{ key }}\" ==> \"This is a value\", with params = { key: \"value\" }\n     * @param expr\n     * @param params\n     */\n    abstract interpolate(\n        expr: InterpolateFunction | string,\n        params?: InterpolationParameters,\n    ): string | undefined;\n}\n\n@Injectable()\nexport class TranslateDefaultParser extends TranslateParser {\n    templateMatcher = /{{\\s?([^{}\\s]*)\\s?}}/g;\n\n    public interpolate(\n        expr: InterpolateFunction | string,\n        params?: InterpolationParameters,\n    ): string | undefined {\n        if (isString(expr)) {\n            return this.interpolateString(expr as string, params);\n        } else if (isFunction(expr)) {\n            return this.interpolateFunction(expr as InterpolateFunction, params);\n        }\n        return undefined;\n    }\n\n    protected interpolateFunction(\n        fn: InterpolateFunction,\n        params?: InterpolationParameters,\n    ): string {\n        return fn(params);\n    }\n\n    protected interpolateString(expr: string, params?: InterpolationParameters): string {\n        if (!params) {\n            return expr;\n        }\n\n        return expr.replace(this.templateMatcher, (substring: string, key: string) => {\n            const replacement = this.getInterpolationReplacement(params, key);\n            return replacement !== undefined ? replacement : substring;\n        });\n    }\n\n    /**\n     * Returns the replacement for an interpolation parameter\n     * @params:\n     */\n    protected getInterpolationReplacement(\n        params: InterpolationParameters,\n        key: string,\n    ): string | undefined {\n        return this.formatValue(getValue(params, key));\n    }\n\n    /**\n     * Converts a value into a useful string representation.\n     * @param value The value to format.\n     * @returns A string representation of the value.\n     */\n    protected formatValue(value: unknown): string | undefined {\n        if (isString(value)) {\n            return value;\n        }\n        if (typeof value === \"number\" || typeof value === \"boolean\") {\n            return value.toString();\n        }\n        if (value === null) {\n            return \"null\";\n        }\n        if (isArray(value)) {\n            return value.join(\", \");\n        }\n        if (isObject(value)) {\n            if (\n                typeof value.toString === \"function\" &&\n                value.toString !== Object.prototype.toString\n            ) {\n                return value.toString();\n            }\n            return JSON.stringify(value); // Pretty-print JSON if no meaningful toString()\n        }\n\n        return undefined;\n    }\n}\n", "import {\n    InterpolatableTranslationObject,\n    FallbackLangChangeEvent,\n    LangChangeEvent,\n    TranslationChangeEvent,\n    Language,\n    InterpolatableTranslation,\n} from \"./translate.service\";\nimport { Observable, Subject } from \"rxjs\";\nimport { getValue, mergeDeep } from \"./util\";\nimport { Injectable } from \"@angular/core\";\n\nexport type DeepReadonly<T> = {\n    readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];\n};\n\n@Injectable()\nexport class TranslateStore {\n    private _onTranslationChange: Subject<TranslationChangeEvent> =\n        new Subject<TranslationChangeEvent>();\n    private _onLangChange: Subject<LangChangeEvent> = new Subject<LangChangeEvent>();\n    private _onFallbackLangChange: Subject<FallbackLangChangeEvent> =\n        new Subject<FallbackLangChangeEvent>();\n\n    private fallbackLang: Language | null = null;\n    private currentLang!: Language;\n\n    private translations: Record<Language, InterpolatableTranslationObject> = {};\n    private languages: Language[] = [];\n\n    public getTranslations(language: Language): DeepReadonly<InterpolatableTranslationObject> {\n        return this.translations[language];\n    }\n\n    public setTranslations(\n        language: Language,\n        translations: InterpolatableTranslationObject,\n        extend: boolean,\n    ): void {\n        this.translations[language] =\n            extend && this.hasTranslationFor(language)\n                ? mergeDeep(this.translations[language], translations)\n                : translations;\n        this.addLanguages([language]);\n        this._onTranslationChange.next({\n            lang: language,\n            translations: this.getTranslations(language),\n        });\n    }\n\n    public getLanguages(): readonly Language[] {\n        return this.languages;\n    }\n\n    public getCurrentLang(): Language {\n        return this.currentLang;\n    }\n\n    public getFallbackLang(): Language | null {\n        return this.fallbackLang;\n    }\n\n    /**\n     * Changes the fallback lang\n     */\n    public setFallbackLang(lang: string, emitChange = true): void {\n        this.fallbackLang = lang;\n        if (emitChange) {\n            this._onFallbackLangChange.next({ lang: lang, translations: this.translations[lang] });\n        }\n    }\n\n    public setCurrentLang(lang: string, emitChange = true): void {\n        this.currentLang = lang;\n        if (emitChange) {\n            this._onLangChange.next({ lang: lang, translations: this.translations[lang] });\n        }\n    }\n\n    /**\n     * An Observable to listen to translation change events\n     * onTranslationChange.subscribe((params: TranslationChangeEvent) => {\n     *     // do something\n     * });\n     */\n    get onTranslationChange(): Observable<TranslationChangeEvent> {\n        return this._onTranslationChange.asObservable();\n    }\n\n    /**\n     * An Observable to listen to lang change events\n     * onLangChange.subscribe((params: LangChangeEvent) => {\n     *     // do something\n     * });\n     */\n    get onLangChange(): Observable<LangChangeEvent> {\n        return this._onLangChange.asObservable();\n    }\n\n    /**\n     * An Observable to listen to fallback lang change events\n     * onFallbackLangChange.subscribe((params: FallbackLangChangeEvent) => {\n     *     // do something\n     * });\n     */\n    get onFallbackLangChange(): Observable<FallbackLangChangeEvent> {\n        return this._onFallbackLangChange.asObservable();\n    }\n\n    public addLanguages(languages: Language[]): void {\n        this.languages = Array.from(new Set([...this.languages, ...languages]));\n    }\n\n    public hasTranslationFor(lang: string) {\n        return typeof this.translations[lang] !== \"undefined\";\n    }\n\n    public deleteTranslations(lang: string) {\n        delete this.translations[lang];\n    }\n\n    public getTranslation(key: string): InterpolatableTranslation {\n        let text = this.getValue(this.currentLang, key);\n\n        if (\n            text === undefined &&\n            this.fallbackLang != null &&\n            this.fallbackLang !== this.currentLang\n        ) {\n            text = this.getValue(this.fallbackLang, key);\n        }\n        return text;\n    }\n\n    protected getValue(language: Language, key: string): InterpolatableTranslation {\n        return getValue(this.getTranslations(language), key) as InterpolatableTranslation;\n    }\n}\n", "import { inject, Injectable, InjectionToken } from \"@angular/core\";\nimport { concat, defer, forkJoin, isObservable, Observable, of } from \"rxjs\";\nimport { concatMap, map, shareReplay, switchMap, take } from \"rxjs/operators\";\nimport { MissingTranslationHandler } from \"./missing-translation-handler\";\nimport { TranslateCompiler } from \"./translate.compiler\";\nimport { TranslateLoader } from \"./translate.loader\";\nimport { InterpolateFunction, TranslateParser } from \"./translate.parser\";\nimport { TranslateStore } from \"./translate.store\";\nimport { insertValue, isArray, isDefinedAndNotNull, isDict, isString } from \"./util\";\n\n/**\n * Configuration object for the translation service.\n *\n * Provides options to customize translation behavior, including setting the primary language,\n * specifying a fallback language, and other deprecated flags for legacy support.\n */\nexport interface TranslateServiceConfig {\n    lang?: Language;\n    fallbackLang?: Language | null;\n    extend: boolean;\n}\n\nexport const TRANSLATE_SERVICE_CONFIG = new InjectionToken<TranslateServiceConfig>(\n    \"TRANSLATE_CONFIG\",\n);\n\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nexport type InterpolationParameters = Record<string, any>;\n\nexport type StrictTranslation = string | StrictTranslation[] | TranslationObject | undefined | null;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Translation = StrictTranslation | any;\n\nexport interface TranslationObject {\n    [key: string]: StrictTranslation;\n}\n\nexport type InterpolatableTranslation =\n    | string\n    | InterpolatableTranslation[]\n    | InterpolateFunction\n    | InterpolatableTranslationObject\n    | undefined\n    | null;\n\nexport interface InterpolatableTranslationObject {\n    [key: string]: InterpolatableTranslation;\n}\n\nexport type Language = string;\n\nexport interface TranslationChangeEvent {\n    translations: InterpolatableTranslationObject;\n    lang: string;\n}\n\nexport interface LangChangeEvent {\n    lang: string;\n    translations: InterpolatableTranslationObject;\n}\n\nexport interface FallbackLangChangeEvent {\n    lang: string;\n    translations: InterpolatableTranslationObject;\n}\n\n/** @deprecated use `FallbackLangChangeEvent` */\nexport type DefaultLangChangeEvent = FallbackLangChangeEvent;\n\ndeclare interface Window {\n    navigator: {\n        languages?: string[];\n        language?: string;\n        browserLanguage?: string;\n        userLanguage?: string;\n    };\n}\n\ndeclare const window: Window;\n\nconst makeObservable = <T>(value: T | Observable<T>): Observable<T> => {\n    return isObservable(value) ? value : of(value);\n};\n\nexport abstract class ITranslateService {\n    public abstract readonly onTranslationChange: Observable<TranslationChangeEvent>;\n    public abstract readonly onLangChange: Observable<LangChangeEvent>;\n    public abstract readonly onFallbackLangChange: Observable<FallbackLangChangeEvent>;\n\n    public abstract use(lang: Language): Observable<InterpolatableTranslationObject>;\n\n    public abstract setFallbackLang(lang: Language): Observable<InterpolatableTranslationObject>;\n    public abstract getFallbackLang(): Language | null;\n\n    public abstract addLangs(languages: Language[]): void;\n    public abstract getLangs(): readonly Language[];\n    public abstract reloadLang(lang: Language): Observable<InterpolatableTranslationObject>;\n    public abstract resetLang(lang: Language): void;\n\n    public abstract instant(\n        key: string | string[],\n        interpolateParams?: InterpolationParameters,\n    ): Translation;\n    public abstract stream(\n        key: string | string[],\n        interpolateParams?: InterpolationParameters,\n    ): Observable<Translation>;\n    public abstract getStreamOnTranslationChange(\n        key: string | string[],\n        interpolateParams?: InterpolationParameters,\n    ): Observable<Translation>;\n\n    public abstract set(\n        key: string,\n        translation: string | TranslationObject,\n        lang?: Language,\n    ): void;\n    public abstract get(\n        key: string | string[],\n        interpolateParams?: InterpolationParameters,\n    ): Observable<Translation>;\n\n    public abstract setTranslation(\n        lang: Language,\n        translations: TranslationObject,\n        shouldMerge?: boolean,\n    ): void;\n    public abstract getParsedResult(\n        key: string | string[],\n        interpolateParams?: InterpolationParameters,\n    ): StrictTranslation | Observable<StrictTranslation>;\n\n    public abstract getBrowserLang(): Language | undefined;\n    public abstract getBrowserCultureLang(): Language | undefined;\n\n    /**\n     * Returns the current language\n     * @deprecated use `getCurrentLang()`\n     */\n    public abstract readonly currentLang: Language;\n\n    /**\n     * Returns a list of known languages - either loaded\n     * or set by using `addLangs()`\n     * @deprecated use `getLangs()`\n     */\n    public abstract readonly langs: readonly Language[];\n\n    /**\n     * Sets the fallback language\n     * @param lang The language to set\n     * @deprecated use `setFallbackLang(lang)`\n     */\n    public abstract setDefaultLang(lang: Language): Observable<InterpolatableTranslationObject>;\n\n    /**\n     * Gets the fallback language\n     * @deprecated use `getFallbackLang()`\n     */\n    public abstract getDefaultLang(): Language | null;\n\n    /**\n     * Returns the fallback language\n     * @deprectated use `getFallbackLang()`\n     */\n    public abstract readonly defaultLang: Language | null;\n\n    /**\n     * @deprectated use `getFallbackLang()`\n     */\n    public abstract readonly onDefaultLangChange: Observable<DefaultLangChangeEvent>;\n}\n\n@Injectable()\nexport class TranslateService implements ITranslateService {\n    private loadingTranslations!: Observable<InterpolatableTranslationObject>;\n    private pending = false;\n    private _translationRequests: Record<Language, Observable<TranslationObject>> = {};\n    private lastUseLanguage: Language | null = null;\n\n    public currentLoader = inject(TranslateLoader);\n    public compiler = inject(TranslateCompiler);\n    private parser = inject(TranslateParser);\n    private missingTranslationHandler = inject(MissingTranslationHandler);\n    private store: TranslateStore = inject(TranslateStore);\n\n    private readonly extend: boolean = false;\n\n    /**\n     * An Observable to listen to translation change events\n     * onTranslationChange.subscribe((params: TranslationChangeEvent) => {\n     *     // do something\n     * });\n     */\n    public get onTranslationChange(): Observable<TranslationChangeEvent> {\n        return this.store.onTranslationChange;\n    }\n\n    /**\n     * An Observable to listen to lang change events\n     * onLangChange.subscribe((params: LangChangeEvent) => {\n     *     // do something\n     * });\n     */\n    get onLangChange(): Observable<LangChangeEvent> {\n        return this.store.onLangChange;\n    }\n\n    /**\n     * An Observable to listen to fallback lang change events\n     * onFallbackLangChange.subscribe((params: FallbackLangChangeEvent) => {\n     *     // do something\n     * });\n     */\n    get onFallbackLangChange(): Observable<FallbackLangChangeEvent> {\n        return this.store.onFallbackLangChange;\n    }\n\n    /**\n     * @deprecated Use onFallbackLangChange() instead\n     */\n    get onDefaultLangChange(): Observable<DefaultLangChangeEvent> {\n        return this.store.onFallbackLangChange;\n    }\n\n    constructor() {\n        const config: TranslateServiceConfig = {\n            extend: false,\n            fallbackLang: null,\n\n            ...inject<TranslateServiceConfig>(TRANSLATE_SERVICE_CONFIG, {\n                optional: true,\n            }),\n        };\n\n        if (config.lang) {\n            this.use(config.lang);\n        }\n\n        if (config.fallbackLang) {\n            this.setFallbackLang(config.fallbackLang);\n        }\n\n        if (config.extend) {\n            this.extend = true;\n        }\n    }\n\n    /**\n     * Sets the fallback language to use if a translation is not found in the\n     * current language\n     */\n    public setFallbackLang(lang: Language): Observable<InterpolatableTranslationObject> {\n        if (!this.getFallbackLang()) {\n            // on init set the fallbackLang immediately, but do not emit a change yet\n            this.store.setFallbackLang(lang, false);\n        }\n\n        const pending = this.loadOrExtendLanguage(lang);\n        if (isObservable(pending)) {\n            pending.pipe(take(1)).subscribe({\n                next: () => {\n                    this.store.setFallbackLang(lang);\n                },\n                error: () => {\n                    /* ignore here - user can handle it */\n                },\n            });\n            return pending;\n        }\n\n        this.store.setFallbackLang(lang);\n        return of(this.store.getTranslations(lang));\n    }\n\n    /**\n     * Changes the lang currently used\n     */\n    public use(lang: Language): Observable<InterpolatableTranslationObject> {\n        // remember the language that was called\n        // we need this with multiple fast calls to use()\n        // where translation loads might complete in random order\n        this.lastUseLanguage = lang;\n\n        if (!this.getCurrentLang()) {\n            // on init set the currentLang immediately, but do not emit a change yet\n            this.store.setCurrentLang(lang, false);\n        }\n\n        const pending = this.loadOrExtendLanguage(lang);\n        if (isObservable(pending)) {\n            pending.pipe(take(1)).subscribe({\n                next: () => {\n                    this.changeLang(lang);\n                },\n                error: () => {\n                    /* ignore here - use can handle it */\n                },\n            });\n            return pending;\n        }\n\n        this.changeLang(lang);\n        return of(this.store.getTranslations(lang));\n    }\n\n    /**\n     * Retrieves the given translations\n     */\n    private loadOrExtendLanguage(lang: Language): Observable<TranslationObject> | undefined {\n        // if this language is unavailable or extend is true, ask for it\n        if (!this.store.hasTranslationFor(lang) || this.extend) {\n            this._translationRequests[lang] =\n                this._translationRequests[lang] || this.loadAndCompileTranslations(lang);\n            return this._translationRequests[lang];\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Changes the current lang\n     */\n    private changeLang(lang: Language): void {\n        if (lang !== this.lastUseLanguage) {\n            // received new language data,\n            // but this was not the one requested last\n            return;\n        }\n\n        this.store.setCurrentLang(lang);\n    }\n\n    public getCurrentLang(): Language {\n        return this.store.getCurrentLang();\n    }\n\n    private loadAndCompileTranslations(\n        lang: Language,\n    ): Observable<InterpolatableTranslationObject> {\n        this.pending = true;\n\n        const loadingTranslations = this.currentLoader\n            .getTranslation(lang)\n            .pipe(shareReplay(1), take(1));\n\n        this.loadingTranslations = loadingTranslations.pipe(\n            map((res: TranslationObject) => this.compiler.compileTranslations(res, lang)),\n            shareReplay(1),\n            take(1),\n        );\n\n        this.loadingTranslations.subscribe({\n            next: (res: InterpolatableTranslationObject) => {\n                this.store.setTranslations(lang, res, this.extend);\n                this.pending = false;\n            },\n            error: (err) => {\n                void err;\n                this.pending = false;\n            },\n        });\n\n        return loadingTranslations;\n    }\n\n    /**\n     * Manually sets an object of translations for a given language\n     * after passing it through the compiler\n     */\n    public setTranslation(\n        lang: Language,\n        translations: TranslationObject,\n        shouldMerge = false,\n    ): void {\n        const interpolatableTranslations: InterpolatableTranslationObject =\n            this.compiler.compileTranslations(translations, lang);\n        this.store.setTranslations(lang, interpolatableTranslations, shouldMerge || this.extend);\n    }\n\n    public getLangs(): readonly Language[] {\n        return this.store.getLanguages();\n    }\n\n    /**\n     * Add available languages\n     */\n    public addLangs(languages: Language[]): void {\n        this.store.addLanguages(languages);\n    }\n\n    private getParsedResultForKey(\n        key: string,\n        interpolateParams?: InterpolationParameters,\n    ): StrictTranslation | Observable<StrictTranslation> {\n        const textToInterpolate = this.getTextToInterpolate(key);\n\n        if (isDefinedAndNotNull(textToInterpolate)) {\n            return this.runInterpolation(textToInterpolate, interpolateParams);\n        }\n\n        const res = this.missingTranslationHandler.handle({\n            key,\n            translateService: this,\n            ...(interpolateParams !== undefined && { interpolateParams }),\n        });\n\n        return res !== undefined ? res : key;\n    }\n\n    /**\n     * Gets the fallback language. null if none is defined\n     */\n    public getFallbackLang(): Language | null {\n        return this.store.getFallbackLang();\n    }\n\n    private getTextToInterpolate(key: string): InterpolatableTranslation | undefined {\n        return this.store.getTranslation(key);\n    }\n\n    private runInterpolation(\n        translations: InterpolatableTranslation,\n        interpolateParams?: InterpolationParameters,\n    ): StrictTranslation {\n        if (!isDefinedAndNotNull(translations)) {\n            return;\n        }\n\n        if (isArray(translations)) {\n            return this.runInterpolationOnArray(translations, interpolateParams);\n        }\n\n        if (isDict(translations)) {\n            return this.runInterpolationOnDict(translations, interpolateParams);\n        }\n\n        return this.parser.interpolate(translations, interpolateParams);\n    }\n\n    private runInterpolationOnArray(\n        translations: InterpolatableTranslation,\n        interpolateParams: InterpolationParameters | undefined,\n    ) {\n        return (translations as StrictTranslation[]).map((translation) =>\n            this.runInterpolation(translation, interpolateParams),\n        );\n    }\n\n    private runInterpolationOnDict(\n        translations: InterpolatableTranslationObject,\n        interpolateParams: InterpolationParameters | undefined,\n    ) {\n        const result: TranslationObject = {};\n        for (const key in translations) {\n            const res = this.runInterpolation(translations[key], interpolateParams);\n            if (res !== undefined) {\n                result[key] = res;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the parsed result of the translations\n     */\n    public getParsedResult(\n        key: string | string[],\n        interpolateParams?: InterpolationParameters,\n    ): StrictTranslation | Observable<StrictTranslation> {\n        return key instanceof Array\n            ? this.getParsedResultForArray(key, interpolateParams)\n            : this.getParsedResultForKey(key, interpolateParams);\n    }\n\n    private getParsedResultForArray(\n        key: string[],\n        interpolateParams: InterpolationParameters | undefined,\n    ) {\n        const result: Record<string, StrictTranslation | Observable<StrictTranslation>> = {};\n\n        let observables = false;\n        for (const k of key) {\n            result[k] = this.getParsedResultForKey(k, interpolateParams);\n            observables = observables || isObservable(result[k]);\n        }\n\n        if (!observables) {\n            return result as TranslationObject;\n        }\n\n        const sources: Observable<StrictTranslation>[] = key.map((k) => makeObservable(result[k]));\n        return forkJoin(sources).pipe(\n            map((arr: StrictTranslation[]) => {\n                const obj: TranslationObject = {};\n                arr.forEach((value: StrictTranslation, index: number) => {\n                    obj[key[index]] = value;\n                });\n                return obj;\n            }),\n        );\n    }\n\n    /**\n     * Gets the translated value of a key (or an array of keys)\n     * @returns the translated key, or an object of translated keys\n     */\n    public get(\n        key: string | string[],\n        interpolateParams?: InterpolationParameters,\n    ): Observable<Translation> {\n        if (!isDefinedAndNotNull(key) || !key.length) {\n            throw new Error(`Parameter \"key\" is required and cannot be empty`);\n        }\n        // check if we are loading a new translation to use\n        if (this.pending) {\n            return this.loadingTranslations.pipe(\n                concatMap(() => {\n                    return makeObservable(this.getParsedResult(key, interpolateParams));\n                }),\n            );\n        }\n\n        return makeObservable(this.getParsedResult(key, interpolateParams));\n    }\n\n    /**\n     * Returns a stream of translated values of a key (or an array of keys) which updates\n     * whenever the translation changes.\n     * @returns A stream of the translated key, or an object of translated keys\n     */\n    public getStreamOnTranslationChange(\n        key: string | string[],\n        interpolateParams?: InterpolationParameters,\n    ): Observable<Translation> {\n        if (!isDefinedAndNotNull(key) || !key.length) {\n            throw new Error(`Parameter \"key\" is required and cannot be empty`);\n        }\n\n        return concat(\n            defer(() => this.get(key, interpolateParams)),\n            this.onTranslationChange.pipe(\n                switchMap(() => {\n                    const res = this.getParsedResult(key, interpolateParams);\n                    return makeObservable(res);\n                }),\n            ),\n        );\n    }\n\n    /**\n     * Returns a stream of translated values of a key (or an array of keys) which updates\n     * whenever the language changes.\n     * @returns A stream of the translated key, or an object of translated keys\n     */\n    public stream(\n        key: string | string[],\n        interpolateParams?: InterpolationParameters,\n    ): Observable<Translation> {\n        if (!isDefinedAndNotNull(key) || !key.length) {\n            throw new Error(`Parameter \"key\" required`);\n        }\n\n        return concat(\n            defer(() => this.get(key, interpolateParams)),\n            this.onLangChange.pipe(\n                switchMap(() => {\n                    const res = this.getParsedResult(key, interpolateParams);\n                    return makeObservable(res);\n                }),\n            ),\n        );\n    }\n\n    /**\n     * Returns a translation instantly from the internal state of loaded translation.\n     * All rules regarding the current language, the preferred language of even fallback languages\n     * will be used except any promise handling.\n     */\n    public instant(\n        key: string | string[],\n        interpolateParams?: InterpolationParameters,\n    ): Translation {\n        if (!isDefinedAndNotNull(key) || key.length === 0) {\n            throw new Error('Parameter \"key\" is required and cannot be empty');\n        }\n\n        const result = this.getParsedResult(key, interpolateParams);\n\n        if (isObservable(result)) {\n            if (Array.isArray(key)) {\n                return key.reduce((acc: Record<string, string>, currKey: string) => {\n                    acc[currKey] = currKey;\n                    return acc;\n                }, {});\n            }\n            return key;\n        }\n\n        return result;\n    }\n\n    /**\n     * Sets the translated value of a key, after compiling it\n     */\n    public set(\n        key: string,\n        translation: string | TranslationObject,\n        lang: Language = this.getCurrentLang(),\n    ): void {\n        this.store.setTranslations(\n            lang,\n            insertValue(\n                this.store.getTranslations(lang),\n                key,\n                isString(translation)\n                    ? this.compiler.compile(translation, lang)\n                    : this.compiler.compileTranslations(translation, lang),\n            ),\n            false,\n        );\n    }\n\n    /**\n     * Allows reloading the lang file from the file\n     */\n    public reloadLang(lang: Language): Observable<InterpolatableTranslationObject> {\n        this.resetLang(lang);\n        return this.loadAndCompileTranslations(lang);\n    }\n\n    /**\n     * Deletes inner translation\n     */\n    public resetLang(lang: Language): void {\n        delete this._translationRequests[lang];\n        this.store.deleteTranslations(lang);\n    }\n\n    /**\n     * Returns the language code name from the browser, e.g. \"de\"\n     */\n    public static getBrowserLang(): Language | undefined {\n        if (typeof window === \"undefined\" || !window.navigator) {\n            return undefined;\n        }\n\n        const browserLang = this.getBrowserCultureLang();\n\n        return browserLang ? browserLang.split(/[-_]/)[0] : undefined;\n    }\n\n    /**\n     * Returns the culture language code name from the browser, e.g. \"de-DE\"\n     */\n    public static getBrowserCultureLang(): Language | undefined {\n        if (typeof window === \"undefined\" || typeof window.navigator === \"undefined\") {\n            return undefined;\n        }\n\n        return window.navigator.languages\n            ? window.navigator.languages[0]\n            : window.navigator.language ||\n                  window.navigator.browserLanguage ||\n                  window.navigator.userLanguage;\n    }\n\n    public getBrowserLang(): Language | undefined {\n        return TranslateService.getBrowserLang();\n    }\n\n    public getBrowserCultureLang(): Language | undefined {\n        return TranslateService.getBrowserCultureLang();\n    }\n\n    /** Deprecations **/\n\n    /**\n     * @deprecated use `getFallbackLang()`\n     */\n    get defaultLang(): Language | null {\n        return this.getFallbackLang();\n    }\n\n    /**\n     * The lang currently used\n     * @deprecated use `getCurrentLang()`\n     */\n    get currentLang(): Language {\n        return this.store.getCurrentLang();\n    }\n\n    /**\n     * @deprecated use `getLangs()`\n     */\n    get langs(): readonly Language[] {\n        return this.store.getLanguages();\n    }\n\n    /**\n     * Sets the  language to use as a fallback\n     * @deprecated use setFallbackLanguage()\n     */\n    public setDefaultLang(lang: Language): Observable<InterpolatableTranslationObject> {\n        return this.setFallbackLang(lang);\n    }\n\n    /**\n     * Gets the fallback language used\n     * @deprecated use getFallbackLang()\n     */\n    public getDefaultLang(): Language | null {\n        return this.getFallbackLang();\n    }\n}\n", "import {\n    AfterViewChecked,\n    ChangeDetectorRef,\n    Directive,\n    ElementRef,\n    inject,\n    Input,\n    OnDestroy,\n} from \"@angular/core\";\nimport { Subscription, isObservable } from \"rxjs\";\nimport {\n    FallbackLangChangeEvent,\n    InterpolatableTranslation,\n    LangChangeEvent,\n    TranslateService,\n    TranslationChangeEvent,\n    StrictTranslation,\n    InterpolationParameters,\n} from \"./translate.service\";\nimport { equals, isDefinedAndNotNull, isString } from \"./util\";\n\ninterface ExtendedNode extends Text {\n    originalContent: string;\n    currentValue: string;\n    lookupKey: string;\n    lastKey: string | null;\n    data: string;\n}\n\n@Directive({\n    // eslint-disable-next-line @angular-eslint/directive-selector\n    selector: \"[translate],[ngx-translate]\",\n    standalone: true,\n})\nexport class TranslateDirective implements AfterViewChecked, OnDestroy {\n    private translateService: TranslateService = inject(TranslateService);\n    private element: ElementRef = inject(ElementRef);\n    private _ref: ChangeDetectorRef = inject(ChangeDetectorRef);\n\n    private key!: string;\n    private lastParams?: InterpolationParameters;\n    private currentParams?: InterpolationParameters;\n    private readonly onLangChangeSub!: Subscription;\n    private readonly onFallbackLangChangeSub!: Subscription;\n    private readonly onTranslationChangeSub!: Subscription;\n\n    @Input() set translate(key: string) {\n        if (key) {\n            this.key = key;\n            this.checkNodes();\n        }\n    }\n\n    @Input() set translateParams(params: InterpolationParameters) {\n        if (!equals(this.currentParams, params)) {\n            this.currentParams = params;\n            this.checkNodes(true);\n        }\n    }\n\n    constructor() {\n        // subscribe to onTranslationChange event, in case the translations of the current lang change\n        if (!this.onTranslationChangeSub) {\n            this.onTranslationChangeSub = this.translateService.onTranslationChange.subscribe(\n                (event: TranslationChangeEvent) => {\n                    if (event.lang === this.translateService.currentLang) {\n                        this.checkNodes(true, event.translations);\n                    }\n                },\n            );\n        }\n\n        // subscribe to onLangChange event, in case the language changes\n        if (!this.onLangChangeSub) {\n            this.onLangChangeSub = this.translateService.onLangChange.subscribe(\n                (event: LangChangeEvent) => {\n                    this.checkNodes(true, event.translations);\n                },\n            );\n        }\n\n        // subscribe to onFallbackLangChange event, in case the fallback language changes\n        if (!this.onFallbackLangChangeSub) {\n            this.onFallbackLangChangeSub = this.translateService.onFallbackLangChange.subscribe(\n                (event: FallbackLangChangeEvent) => {\n                    void event;\n                    this.checkNodes(true);\n                },\n            );\n        }\n    }\n\n    ngAfterViewChecked() {\n        this.checkNodes();\n    }\n\n    checkNodes(forceUpdate = false, translations?: InterpolatableTranslation) {\n        let nodes: NodeList = this.element.nativeElement.childNodes;\n        // if the element is empty\n        if (!nodes.length) {\n            // we add the key as content\n            this.setContent(this.element.nativeElement, this.key);\n            nodes = this.element.nativeElement.childNodes;\n        }\n\n        nodes.forEach((n) => {\n            const node = n as ExtendedNode;\n            if (node.nodeType === 3) {\n                // node type 3 is a text node\n                let key!: string;\n                if (forceUpdate) {\n                    node.lastKey = null;\n                }\n                if (isDefinedAndNotNull(node.lookupKey)) {\n                    key = node.lookupKey;\n                } else if (this.key) {\n                    key = this.key;\n                } else {\n                    const content = this.getContent(node);\n                    const trimmedContent = content.trim();\n                    if (trimmedContent.length) {\n                        node.lookupKey = trimmedContent;\n                        // we want to use the content as a key, not the translation value\n                        if (content !== node.currentValue) {\n                            key = trimmedContent;\n                            // the content was changed from the user, we'll use it as a reference if needed\n                            node.originalContent = content || node.originalContent;\n                        } else if (node.originalContent) {\n                            // the content seems ok, but the lang has changed\n                            // the current content is the translation, not the key, use the last real content as key\n                            key = node.originalContent.trim();\n                        }\n                    }\n                }\n                this.updateValue(key, node, translations);\n            }\n        });\n    }\n\n    updateValue(key: string, node: ExtendedNode, translations?: InterpolatableTranslation) {\n        if (key) {\n            if (node.lastKey === key && this.lastParams === this.currentParams) {\n                return;\n            }\n\n            this.lastParams = this.currentParams;\n\n            const onTranslation = (res: StrictTranslation) => {\n                if (res !== key || !node.lastKey) {\n                    node.lastKey = key;\n                }\n                if (!node.originalContent) {\n                    node.originalContent = this.getContent(node);\n                }\n\n                if (isString(res)) {\n                    node.currentValue = res;\n                } else if (!isDefinedAndNotNull(res)) {\n                    node.currentValue = node.originalContent || key;\n                } else {\n                    node.currentValue = JSON.stringify(res);\n                }\n\n                // we replace in the original content to preserve spaces that we might have trimmed\n                this.setContent(\n                    node,\n                    this.key\n                        ? node.currentValue\n                        : node.originalContent.replace(key, node.currentValue),\n                );\n                this._ref.markForCheck();\n            };\n\n            if (isDefinedAndNotNull(translations)) {\n                const res = this.translateService.getParsedResult(key, this.currentParams);\n                if (isObservable(res)) {\n                    res.subscribe({ next: onTranslation });\n                } else {\n                    onTranslation(res);\n                }\n            } else {\n                this.translateService.get(key, this.currentParams).subscribe(onTranslation);\n            }\n        }\n    }\n\n    getContent(node: ExtendedNode): string {\n        return (isDefinedAndNotNull(node.textContent) ? node.textContent : node.data) as string;\n    }\n\n    setContent(node: ExtendedNode, content: string): void {\n        if (isDefinedAndNotNull(node.textContent)) {\n            node.textContent = content;\n        } else {\n            node.data = content;\n        }\n    }\n\n    ngOnDestroy() {\n        if (this.onLangChangeSub) {\n            this.onLangChangeSub.unsubscribe();\n        }\n\n        if (this.onFallbackLangChangeSub) {\n            this.onFallbackLangChangeSub.unsubscribe();\n        }\n\n        if (this.onTranslationChangeSub) {\n            this.onTranslationChangeSub.unsubscribe();\n        }\n    }\n}\n", "import {\n    ChangeDetectorRef,\n    inject,\n    Injectable,\n    OnDestroy,\n    Pipe,\n    PipeTransform,\n} from \"@angular/core\";\nimport { isObservable, Subscription } from \"rxjs\";\nimport {\n    InterpolatableTranslationObject,\n    LangChangeEvent,\n    TranslateService,\n    TranslationChangeEvent,\n    StrictTranslation,\n    InterpolationParameters,\n} from \"./translate.service\";\nimport { equals, isDefinedAndNotNull, isDict, isString } from \"./util\";\n\n@Injectable()\n@Pipe({\n    name: \"translate\",\n    standalone: true,\n    pure: false, // required to update the value when the promise is resolved\n})\nexport class TranslatePipe implements PipeTransform, OnDestroy {\n    private translate: TranslateService = inject(TranslateService);\n    private _ref: ChangeDetectorRef = inject(ChangeDetectorRef);\n\n    private value: StrictTranslation = \"\";\n    lastKey: string | null = null;\n    lastParams: InterpolationParameters[] = [];\n    onTranslationChange: Subscription | undefined;\n    onLangChange: Subscription | undefined;\n    onFallbackLangChange: Subscription | undefined;\n\n    updateValue(\n        key: string,\n        interpolateParams?: InterpolationParameters,\n        translations?: InterpolatableTranslationObject,\n    ): void {\n        const onTranslation = (res: StrictTranslation) => {\n            this.value = res !== undefined ? res : key;\n            this.lastKey = key;\n            this._ref.markForCheck();\n        };\n        if (translations) {\n            const res = this.translate.getParsedResult(key, interpolateParams);\n            if (isObservable(res)) {\n                res.subscribe(onTranslation);\n            } else {\n                onTranslation(res);\n            }\n        }\n        this.translate.get(key, interpolateParams).subscribe(onTranslation);\n    }\n\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    transform(query: string | undefined | null, ...args: any[]): any {\n        if (!query || !query.length) {\n            return query;\n        }\n\n        // if we ask another time for the same key, return the last value\n        if (equals(query, this.lastKey) && equals(args, this.lastParams)) {\n            return this.value;\n        }\n\n        let interpolateParams: InterpolationParameters | undefined = undefined;\n        if (isDefinedAndNotNull(args[0]) && args.length) {\n            if (isString(args[0]) && args[0].length) {\n                // we accept objects written in the template such as {n:1}, {'n':1}, {n:'v'}\n                // this is why we might need to change it to real JSON objects such as {\"n\":1} or {\"n\":\"v\"}\n                const validArgs: string = args[0]\n                    .replace(/(')?([a-zA-Z0-9_]+)(')?(\\s)?:/g, '\"$2\":')\n                    .replace(/:(\\s)?(')(.*?)(')/g, ':\"$3\"');\n                try {\n                    interpolateParams = JSON.parse(validArgs);\n                } catch (e) {\n                    void e;\n                    throw new SyntaxError(\n                        `Wrong parameter in TranslatePipe. Expected a valid Object, received: ${args[0]}`,\n                    );\n                }\n            } else if (isDict(args[0])) {\n                interpolateParams = args[0];\n            }\n        }\n\n        // store the query in case it changes\n        this.lastKey = query;\n\n        // store the params in case they change\n        this.lastParams = args;\n\n        // set the value\n        this.updateValue(query, interpolateParams);\n\n        // if there is a subscription to onLangChange, clean it\n        this._dispose();\n\n        // subscribe to onTranslationChange event, in case the translations change\n        if (!this.onTranslationChange) {\n            this.onTranslationChange = this.translate.onTranslationChange.subscribe(\n                (event: TranslationChangeEvent) => {\n                    if (\n                        (this.lastKey && event.lang === this.translate.getCurrentLang()) ||\n                        event.lang === this.translate.getFallbackLang()\n                    ) {\n                        this.lastKey = null;\n                        this.updateValue(query, interpolateParams, event.translations);\n                    }\n                },\n            );\n        }\n\n        // subscribe to onLangChange event, in case the language changes\n        if (!this.onLangChange) {\n            this.onLangChange = this.translate.onLangChange.subscribe((event: LangChangeEvent) => {\n                if (this.lastKey) {\n                    this.lastKey = null; // we want to make sure it doesn't return the same value until it's been updated\n                    this.updateValue(query, interpolateParams, event.translations);\n                }\n            });\n        }\n\n        // subscribe to onDefaultLangChange event, in case the fallback language changes\n        if (!this.onFallbackLangChange) {\n            this.onFallbackLangChange = this.translate.onFallbackLangChange.subscribe(() => {\n                if (this.lastKey) {\n                    this.lastKey = null; // we want to make sure it doesn't return the same value until it's been updated\n                    this.updateValue(query, interpolateParams);\n                }\n            });\n        }\n\n        return this.value;\n    }\n\n    /**\n     * Clean any existing subscription to change events\n     */\n    private _dispose(): void {\n        if (typeof this.onTranslationChange !== \"undefined\") {\n            this.onTranslationChange.unsubscribe();\n            this.onTranslationChange = undefined;\n        }\n        if (typeof this.onLangChange !== \"undefined\") {\n            this.onLangChange.unsubscribe();\n            this.onLangChange = undefined;\n        }\n        if (typeof this.onFallbackLangChange !== \"undefined\") {\n            this.onFallbackLangChange.unsubscribe();\n            this.onFallbackLangChange = undefined;\n        }\n    }\n\n    ngOnDestroy(): void {\n        this._dispose();\n    }\n}\n", "import {\n    Language,\n    TRANSLATE_SERVICE_CONFIG,\n    TranslateService,\n    TranslateServiceConfig,\n} from \"./translate.service\";\nimport { ClassProvider, Provider, Type } from \"@angular/core\";\nimport { TranslateNoOpLoader, TranslateLoader } from \"./translate.loader\";\nimport { TranslateCompiler, TranslateNoOpCompiler } from \"./translate.compiler\";\nimport { TranslateDefaultParser, TranslateParser } from \"./translate.parser\";\nimport {\n    DefaultMissingTranslationHandler,\n    MissingTranslationHandler,\n} from \"./missing-translation-handler\";\nimport { TranslateStore } from \"./translate.store\";\n\nexport interface TranslateProviders {\n    loader?: Provider;\n    compiler?: Provider;\n    parser?: Provider;\n    missingTranslationHandler?: Provider;\n}\n\nexport interface ChildTranslateServiceConfig extends Partial<TranslateProviders> {\n    extend?: boolean;\n}\n\nexport interface RootTranslateServiceConfig extends ChildTranslateServiceConfig {\n    fallbackLang?: Language;\n    lang?: Language;\n\n    /* @deprecated use `fallbackLang` */\n    useDefaultLang?: boolean;\n    /* @deprecated use `fallbackLang` */\n    defaultLanguage?: Language;\n}\n\nexport function provideTranslateLoader(loader: Type<TranslateLoader>): ClassProvider {\n    return { provide: TranslateLoader, useClass: loader };\n}\n\nexport function provideTranslateCompiler(compiler: Type<TranslateCompiler>): ClassProvider {\n    return { provide: TranslateCompiler, useClass: compiler };\n}\n\nexport function provideTranslateParser(parser: Type<TranslateParser>): ClassProvider {\n    return { provide: TranslateParser, useClass: parser };\n}\n\nexport function provideMissingTranslationHandler(\n    handler: Type<MissingTranslationHandler>,\n): ClassProvider {\n    return { provide: MissingTranslationHandler, useClass: handler };\n}\n\nexport function provideTranslateService(config: RootTranslateServiceConfig = {}): Provider[] {\n    return defaultProviders(\n        {\n            compiler: provideTranslateCompiler(TranslateNoOpCompiler),\n            parser: provideTranslateParser(TranslateDefaultParser),\n            loader: provideTranslateLoader(TranslateNoOpLoader),\n            missingTranslationHandler: provideMissingTranslationHandler(\n                DefaultMissingTranslationHandler,\n            ),\n            ...config,\n        },\n        true,\n    );\n}\n\nexport function provideChildTranslateService(config: ChildTranslateServiceConfig = {}): Provider[] {\n    return defaultProviders({ extend: true, ...config }, false);\n}\n\nexport function defaultProviders(\n    config: RootTranslateServiceConfig = {},\n    provideStore: boolean,\n): Provider[] {\n    const providers: Provider[] = [];\n\n    if (config.loader) {\n        providers.push(config.loader);\n    }\n    if (config.compiler) {\n        providers.push(config.compiler);\n    }\n    if (config.parser) {\n        providers.push(config.parser);\n    }\n    if (config.missingTranslationHandler) {\n        providers.push(config.missingTranslationHandler);\n    }\n\n    if (provideStore) {\n        providers.push(TranslateStore);\n    }\n\n    if (config.useDefaultLang || config.defaultLanguage) {\n        console.warn(\n            \"The `useDefaultLang` and `defaultLanguage` options are deprecated. Please use `fallbackLang` instead.\",\n        );\n\n        if (config.useDefaultLang === true && config.defaultLanguage) {\n            config.fallbackLang = config.defaultLanguage;\n        }\n    }\n\n    const serviceConfig: TranslateServiceConfig = {\n        fallbackLang: config.fallbackLang ?? null,\n        lang: config.lang,\n        extend: config.extend ?? false,\n    };\n\n    providers.push({\n        provide: TRANSLATE_SERVICE_CONFIG,\n        useValue: serviceConfig,\n    });\n\n    providers.push({\n        provide: TranslateService,\n        useClass: TranslateService,\n        deps: [\n            TranslateStore,\n            TranslateLoader,\n            TranslateCompiler,\n            TranslateParser,\n            MissingTranslationHandler,\n            TRANSLATE_SERVICE_CONFIG,\n        ],\n    });\n\n    return providers;\n}\n", "import { ModuleWithProviders, NgModule } from \"@angular/core\";\nimport { TranslatePipe } from \"./translate.pipe\";\nimport { TranslateDirective } from \"./translate.directive\";\nimport {\n    defaultProviders,\n    provideTranslateCompiler,\n    provideTranslateLoader,\n    provideMissingTranslationHandler,\n    provideTranslateParser,\n    TranslateProviders,\n} from \"./translate.providers\";\nimport { TranslateNoOpCompiler } from \"./translate.compiler\";\nimport { TranslateDefaultParser } from \"./translate.parser\";\nimport { TranslateNoOpLoader } from \"./translate.loader\";\nimport { DefaultMissingTranslationHandler } from \"./missing-translation-handler\";\nimport { Language } from \"./translate.service\";\n\nexport interface TranslateModuleConfig extends TranslateProviders {\n    isolate?: boolean;\n    extend?: boolean;\n    fallbackLang?: Language;\n    lang?: Language;\n\n    /** @deprecated use fallbackLang */\n    defaultLanguage?: string;\n    /** @deprecated use fallbackLang */\n    useDefaultLang?: boolean;\n}\n\n@NgModule({\n    imports: [TranslatePipe, TranslateDirective],\n    exports: [TranslatePipe, TranslateDirective],\n})\nexport class TranslateModule {\n    /**\n     * Use this method in your root module to provide the TranslateService\n     */\n    static forRoot(config: TranslateModuleConfig = {}): ModuleWithProviders<TranslateModule> {\n        return {\n            ngModule: TranslateModule,\n            providers: [\n                ...defaultProviders(\n                    {\n                        compiler: provideTranslateCompiler(TranslateNoOpCompiler),\n                        parser: provideTranslateParser(TranslateDefaultParser),\n                        loader: provideTranslateLoader(TranslateNoOpLoader),\n                        missingTranslationHandler: provideMissingTranslationHandler(\n                            DefaultMissingTranslationHandler,\n                        ),\n                        ...config,\n                    },\n                    true,\n                ),\n            ],\n        };\n    }\n\n    /**\n     * Use this method in your other (non-root) modules to import the directive/pipe\n     */\n    static forChild(config: TranslateModuleConfig = {}): ModuleWithProviders<TranslateModule> {\n        return {\n            ngModule: TranslateModule,\n            providers: [...defaultProviders(config, config.isolate ?? false)],\n        };\n    }\n}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],
  "mappings": "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",
  "names": ["_", "key", "MissingTranslationHandler", "DefaultMissingTranslationHandler", "handle", "params", "factory", "ɵfac", "Injectable", "TranslateCompiler", "TranslateNoOpCompiler", "compile", "value", "lang", "compileTranslations", "translations", "__ngFactoryType__", "TranslateLoader", "TranslateNoOpLoader", "getTranslation", "of", "equals", "o1", "o2", "t1", "t2", "length", "Array", "isArray", "isDict", "keySet", "Object", "create", "isDefinedAndNotNull", "isDefined", "undefined", "isObject", "isString", "isFunction", "cloneDeep", "map", "item", "cloned", "keys", "forEach", "mergeDeep", "target", "source", "output", "assign", "getValue", "split", "shift", "isLastKey", "index", "parseInt", "setValue", "current", "i", "insertValue", "createNestedObject", "dotSeparatedKey", "reduceRight", "acc", "TranslateParser", "TranslateDefaultParser", "templateMatcher", "interpolate", "expr", "interpolateString", "interpolateFunction", "fn", "replace", "substring", "replacement", "getInterpolationReplacement", "formatValue", "toString", "join", "prototype", "JSON", "stringify", "TranslateStore", "_onTranslationChange", "Subject", "_onLangChange", "_onFallbackLangChange", "fallbackLang", "currentLang", "languages", "getTranslations", "language", "setTranslations", "extend", "hasTranslationFor", "addLanguages", "next", "getLanguages", "getCurrentLang", "getFallbackLang", "setFallbackLang", "emitChange", "setCurrentLang", "onTranslationChange", "asObservable", "onLangChange", "onFallbackLangChange", "from", "Set", "deleteTranslations", "text", "TRANSLATE_SERVICE_CONFIG", "InjectionToken", "makeObservable", "isObservable", "ITranslateService", "TranslateService", "loadingTranslations", "pending", "_translationRequests", "lastUseLanguage", "currentLoader", "inject", "compiler", "parser", "missingTranslationHandler", "store", "onDefaultLangChange", "constructor", "config", "optional", "use", "loadOrExtendLanguage", "pipe", "take", "subscribe", "error", "changeLang", "loadAndCompileTranslations", "shareReplay", "res", "err", "setTranslation", "shouldMerge", "interpolatableTranslations", "getLangs", "addLangs", "getParsedResultForKey", "interpolateParams", "textToInterpolate", "getTextToInterpolate", "runInterpolation", "translateService", "runInterpolationOnArray", "runInterpolationOnDict", "translation", "result", "getParsedResult", "getParsedResultForArray", "observables", "k", "sources", "forkJoin", "arr", "obj", "get", "Error", "concatMap", "getStreamOnTranslationChange", "concat", "defer", "switchMap", "stream", "instant", "reduce", "currKey", "set", "reloadLang", "resetLang", "getBrowserLang", "window", "navigator", "browserLang", "getBrowserCultureLang", "browserLanguage", "userLanguage", "defaultLang", "langs", "setDefaultLang", "getDefaultLang", "TranslateDirective", "element", "ElementRef", "_ref", "ChangeDetectorRef", "lastParams", "currentParams", "onLangChangeSub", "onFallbackLangChangeSub", "onTranslationChangeSub", "translate", "checkNodes", "translateParams", "event", "ngAfterViewChecked", "forceUpdate", "nodes", "nativeElement", "childNodes", "setContent", "n", "node", "nodeType", "lastKey", "lookupKey", "content", "getContent", "trimmedContent", "trim", "currentValue", "originalContent", "updateValue", "onTranslation", "markForCheck", "textContent", "data", "ngOnDestroy", "unsubscribe", "selectors", "inputs", "Directive", "args", "selector", "standalone", "Input", "TranslatePipe", "transform", "query", "validArgs", "parse", "e", "SyntaxError", "_dispose", "pure", "Pipe", "name", "provideTranslateLoader", "loader", "provide", "useClass", "provideTranslateCompiler", "provideTranslateParser", "provideMissingTranslationHandler", "handler", "provideTranslateService", "defaultProviders", "provideChildTranslateService", "provideStore", "providers", "push", "useDefaultLang", "defaultLanguage", "console", "warn", "serviceConfig", "useValue", "deps", "TranslateModule", "forRoot", "ngModule", "forChild", "isolate", "ɵmod", "imports", "exports", "NgModule"]
}
