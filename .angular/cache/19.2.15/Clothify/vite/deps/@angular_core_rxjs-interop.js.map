{
  "version": 3,
  "sources": ["../../../../../../../darwin_arm64-fastbuild-ST-2d99d9656325/bin/packages/core/rxjs-interop/src/take_until_destroyed.ts", "../../../../../../../darwin_arm64-fastbuild-ST-2d99d9656325/bin/packages/core/rxjs-interop/src/output_from_observable.ts", "../../../../../../../darwin_arm64-fastbuild-ST-2d99d9656325/bin/packages/core/rxjs-interop/src/output_to_observable.ts", "../../../../../../../darwin_arm64-fastbuild-ST-2d99d9656325/bin/packages/core/rxjs-interop/src/to_observable.ts", "../../../../../../../darwin_arm64-fastbuild-ST-2d99d9656325/bin/packages/core/rxjs-interop/src/to_signal.ts", "../../../../../../../darwin_arm64-fastbuild-ST-2d99d9656325/bin/packages/core/rxjs-interop/src/pending_until_event.ts", "../../../../../../../darwin_arm64-fastbuild-ST-2d99d9656325/bin/packages/core/rxjs-interop/src/rx_resource.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext, DestroyRef, inject} from '@angular/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @publicApi\n */\nexport function takeUntilDestroyed<T>(destroyRef?: DestroyRef): MonoTypeOperatorFunction<T> {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n\n  const destroyed$ = new Observable<void>((observer) => {\n    const unregisterFn = destroyRef!.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n\n  return <T>(source: Observable<T>) => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  DestroyRef,\n  inject,\n  OutputOptions,\n  OutputRef,\n  OutputRefSubscription,\n  ɵRuntimeError,\n  ɵRuntimeErrorCode,\n} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport {takeUntilDestroyed} from './take_until_destroyed';\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef<T> implements OutputRef<T> {\n  private destroyed = false;\n\n  destroyRef = inject(DestroyRef);\n\n  constructor(private source: Observable<T>) {\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n\n  subscribe(callbackFn: (value: T) => void): OutputRefSubscription {\n    if (this.destroyed) {\n      throw new ɵRuntimeError(\n        ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED,\n        ngDevMode &&\n          'Unexpected subscription to destroyed `OutputRef`. ' +\n            'The owning directive/component is destroyed.',\n      );\n    }\n\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: (value) => callbackFn(value),\n    });\n\n    return {\n      unsubscribe: () => subscription.unsubscribe(),\n    };\n  }\n}\n\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @publicApi\n */\nexport function outputFromObservable<T>(\n  observable: Observable<T>,\n  opts?: OutputOptions,\n): OutputRef<T> {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef<T>(observable);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {OutputRef, ɵgetOutputDestroyRef} from '@angular/core';\nimport {Observable} from 'rxjs';\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @publicApi\n */\nexport function outputToObservable<T>(ref: OutputRef<T>): Observable<T> {\n  const destroyRef = ɵgetOutputDestroyRef(ref);\n\n  return new Observable<T>((observer) => {\n    // Complete the observable upon directive/component destroy.\n    // Note: May be `undefined` if an `EventEmitter` is declared outside\n    // of an injection context.\n    destroyRef?.onDestroy(() => observer.complete());\n\n    const subscription = ref.subscribe((v) => observer.next(v));\n    return () => subscription.unsubscribe();\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  DestroyRef,\n  effect,\n  inject,\n  Injector,\n  Signal,\n  untracked,\n  ɵmicrotaskEffect as microtaskEffect,\n} from '@angular/core';\nimport {Observable, ReplaySubject} from 'rxjs';\n\n/**\n * Options for `toObservable`.\n *\n * @developerPreview\n */\nexport interface ToObservableOptions {\n  /**\n   * The `Injector` to use when creating the underlying `effect` which watches the signal.\n   *\n   * If this isn't specified, the current [injection context](guide/di/dependency-injection-context)\n   * will be used.\n   */\n  injector?: Injector;\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nexport function toObservable<T>(source: Signal<T>, options?: ToObservableOptions): Observable<T> {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject<T>(1);\n\n  const watcher = effect(\n    () => {\n      let value: T;\n      try {\n        value = source();\n      } catch (err) {\n        untracked(() => subject.error(err));\n        return;\n      }\n      untracked(() => subject.next(value));\n    },\n    {injector, manualCleanup: true},\n  );\n\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n\n  return subject.asObservable();\n}\n\nexport function toObservableMicrotask<T>(\n  source: Signal<T>,\n  options?: ToObservableOptions,\n): Observable<T> {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject<T>(1);\n\n  const watcher = microtaskEffect(\n    () => {\n      let value: T;\n      try {\n        value = source();\n      } catch (err) {\n        untracked(() => subject.error(err));\n        return;\n      }\n      untracked(() => subject.next(value));\n    },\n    {injector, manualCleanup: true},\n  );\n\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n\n  return subject.asObservable();\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  assertNotInReactiveContext,\n  computed,\n  DestroyRef,\n  inject,\n  Injector,\n  signal,\n  Signal,\n  WritableSignal,\n  ɵRuntimeError,\n  ɵRuntimeErrorCode,\n} from '@angular/core';\nimport {ValueEqualityFn} from '@angular/core/primitives/signals';\nimport {Observable, Subscribable} from 'rxjs';\n\n/**\n * Options for `toSignal`.\n *\n * @publicApi\n */\nexport interface ToSignalOptions<T> {\n  /**\n   * Initial value for the signal produced by `toSignal`.\n   *\n   * This will be the value of the signal until the observable emits its first value.\n   */\n  initialValue?: unknown;\n\n  /**\n   * Whether to require that the observable emits synchronously when `toSignal` subscribes.\n   *\n   * If this is `true`, `toSignal` will assert that the observable produces a value immediately upon\n   * subscription. Setting this option removes the need to either deal with `undefined` in the\n   * signal type or provide an `initialValue`, at the cost of a runtime error if this requirement is\n   * not met.\n   */\n  requireSync?: boolean;\n\n  /**\n   * `Injector` which will provide the `DestroyRef` used to clean up the Observable subscription.\n   *\n   * If this is not provided, a `DestroyRef` will be retrieved from the current [injection\n   * context](guide/di/dependency-injection-context), unless manual cleanup is requested.\n   */\n  injector?: Injector;\n\n  /**\n   * Whether the subscription should be automatically cleaned up (via `DestroyRef`) when\n   * `toSignal`'s creation context is destroyed.\n   *\n   * If manual cleanup is enabled, then `DestroyRef` is not used, and the subscription will persist\n   * until the `Observable` itself completes.\n   */\n  manualCleanup?: boolean;\n\n  /**\n   * Whether `toSignal` should throw errors from the Observable error channel back to RxJS, where\n   * they'll be processed as uncaught exceptions.\n   *\n   * In practice, this means that the signal returned by `toSignal` will keep returning the last\n   * good value forever, as Observables which error produce no further values. This option emulates\n   * the behavior of the `async` pipe.\n   */\n  rejectErrors?: boolean;\n\n  /**\n   * A comparison function which defines equality for values emitted by the observable.\n   *\n   * Equality comparisons are executed against the initial value if one is provided.\n   */\n  equal?: ValueEqualityFn<T>;\n}\n\n// Base case: no options -> `undefined` in the result type.\nexport function toSignal<T>(source: Observable<T> | Subscribable<T>): Signal<T | undefined>;\n// Options with `undefined` initial value and no `requiredSync` -> `undefined`.\nexport function toSignal<T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T | undefined>> & {\n    initialValue?: undefined;\n    requireSync?: false;\n  },\n): Signal<T | undefined>;\n// Options with `null` initial value -> `null`.\nexport function toSignal<T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T | null>> & {initialValue?: null; requireSync?: false},\n): Signal<T | null>;\n// Options with `undefined` initial value and `requiredSync` -> strict result type.\nexport function toSignal<T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T>> & {initialValue?: undefined; requireSync: true},\n): Signal<T>;\n// Options with a more specific initial value type.\nexport function toSignal<T, const U extends T>(\n  source: Observable<T> | Subscribable<T>,\n  options: NoInfer<ToSignalOptions<T | U>> & {initialValue: U; requireSync?: false},\n): Signal<T | U>;\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nexport function toSignal<T, U = undefined>(\n  source: Observable<T> | Subscribable<T>,\n  options?: ToSignalOptions<T | U> & {initialValue?: U},\n): Signal<T | U> {\n  typeof ngDevMode !== 'undefined' &&\n    ngDevMode &&\n    assertNotInReactiveContext(\n      toSignal,\n      'Invoking `toSignal` causes new subscriptions every time. ' +\n        'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.',\n    );\n\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup\n    ? (options?.injector?.get(DestroyRef) ?? inject(DestroyRef))\n    : null;\n\n  const equal = makeToSignalEqual(options?.equal);\n\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state: WritableSignal<State<T | U>>;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({kind: StateKind.NoValue}, {equal});\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal<State<T | U>>(\n      {kind: StateKind.Value, value: options?.initialValue as U},\n      {equal},\n    );\n  }\n\n  let destroyUnregisterFn: (() => void) | undefined;\n\n  // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n  // this, we would subscribe to the observable outside of the current reactive context, avoiding\n  // that side-effect signal reads/writes are attribute to the current consumer. The current\n  // consumer only needs to be notified when the `state` signal changes through the observable\n  // subscription. Additional context (related to async pipe):\n  // https://github.com/angular/angular/pull/50522.\n  const sub = source.subscribe({\n    next: (value) => state.set({kind: StateKind.Value, value}),\n    error: (error) => {\n      if (options?.rejectErrors) {\n        // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n        // the error to end up as an uncaught exception.\n        throw error;\n      }\n      state.set({kind: StateKind.Error, error});\n    },\n    complete: () => {\n      destroyUnregisterFn?.();\n    },\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n\n  if (options?.requireSync && state().kind === StateKind.NoValue) {\n    throw new ɵRuntimeError(\n      ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT,\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.',\n    );\n  }\n\n  // Unsubscribe when the current context is destroyed, if requested.\n  destroyUnregisterFn = cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(\n    () => {\n      const current = state();\n      switch (current.kind) {\n        case StateKind.Value:\n          return current.value;\n        case StateKind.Error:\n          throw current.error;\n        case StateKind.NoValue:\n          // This shouldn't really happen because the error is thrown on creation.\n          throw new ɵRuntimeError(\n            ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT,\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.',\n          );\n      }\n    },\n    {equal: options?.equal},\n  );\n}\n\nfunction makeToSignalEqual<T>(\n  userEquality: ValueEqualityFn<T> = Object.is,\n): ValueEqualityFn<State<T>> {\n  return (a, b) =>\n    a.kind === StateKind.Value && b.kind === StateKind.Value && userEquality(a.value, b.value);\n}\n\nconst enum StateKind {\n  NoValue,\n  Value,\n  Error,\n}\n\ninterface NoValueState {\n  kind: StateKind.NoValue;\n}\n\ninterface ValueState<T> {\n  kind: StateKind.Value;\n  value: T;\n}\n\ninterface ErrorState {\n  kind: StateKind.Error;\n  error: unknown;\n}\n\ntype State<T> = NoValueState | ValueState<T> | ErrorState;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {assertInInjectionContext, PendingTasks, inject, Injector} from '@angular/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\n\n/**\n * Operator which makes the application unstable until the observable emits, completes, errors, or is unsubscribed.\n *\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\n *\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\n *\n * @experimental\n */\nexport function pendingUntilEvent<T>(injector?: Injector): MonoTypeOperatorFunction<T> {\n  if (injector === undefined) {\n    assertInInjectionContext(pendingUntilEvent);\n    injector = inject(Injector);\n  }\n  const taskService = injector.get(PendingTasks);\n\n  return (sourceObservable) => {\n    return new Observable<T>((originalSubscriber) => {\n      // create a new task on subscription\n      const removeTask = taskService.add();\n\n      let cleanedUp = false;\n      function cleanupTask() {\n        if (cleanedUp) {\n          return;\n        }\n\n        removeTask();\n        cleanedUp = true;\n      }\n\n      const innerSubscription = sourceObservable.subscribe({\n        next: (v) => {\n          originalSubscriber.next(v);\n          cleanupTask();\n        },\n        complete: () => {\n          originalSubscriber.complete();\n          cleanupTask();\n        },\n        error: (e) => {\n          originalSubscriber.error(e);\n          cleanupTask();\n        },\n      });\n      innerSubscription.add(() => {\n        originalSubscriber.unsubscribe();\n        cleanupTask();\n      });\n      return innerSubscription;\n    });\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  assertInInjectionContext,\n  resource,\n  ResourceLoaderParams,\n  ResourceRef,\n  Signal,\n  signal,\n  BaseResourceOptions,\n} from '@angular/core';\nimport {Observable, Subscription} from 'rxjs';\n\n/**\n * Like `ResourceOptions` but uses an RxJS-based `loader`.\n *\n * @experimental\n */\nexport interface RxResourceOptions<T, R> extends BaseResourceOptions<T, R> {\n  loader: (params: ResourceLoaderParams<R>) => Observable<T>;\n}\n\n/**\n * Like `resource` but uses an RxJS based `loader` which maps the request to an `Observable` of the\n * resource's value.\n *\n * @experimental\n */\nexport function rxResource<T, R>(\n  opts: RxResourceOptions<T, R> & {defaultValue: NoInfer<T>},\n): ResourceRef<T>;\n\n/**\n * Like `resource` but uses an RxJS based `loader` which maps the request to an `Observable` of the\n * resource's value.\n *\n * @experimental\n */\nexport function rxResource<T, R>(opts: RxResourceOptions<T, R>): ResourceRef<T | undefined>;\nexport function rxResource<T, R>(opts: RxResourceOptions<T, R>): ResourceRef<T | undefined> {\n  opts?.injector || assertInInjectionContext(rxResource);\n  return resource<T, R>({\n    ...opts,\n    loader: undefined,\n    stream: (params) => {\n      let sub: Subscription;\n\n      // Track the abort listener so it can be removed if the Observable completes (as a memory\n      // optimization).\n      const onAbort = () => sub.unsubscribe();\n      params.abortSignal.addEventListener('abort', onAbort);\n\n      // Start off stream as undefined.\n      const stream = signal<{value: T} | {error: unknown}>({value: undefined as T});\n      let resolve: ((value: Signal<{value: T} | {error: unknown}>) => void) | undefined;\n      const promise = new Promise<Signal<{value: T} | {error: unknown}>>((r) => (resolve = r));\n\n      function send(value: {value: T} | {error: unknown}): void {\n        stream.set(value);\n        resolve?.(stream);\n        resolve = undefined;\n      }\n\n      sub = opts.loader(params).subscribe({\n        next: (value) => send({value}),\n        error: (error) => {\n          send({error});\n          params.abortSignal.removeEventListener('abort', onAbort);\n        },\n        complete: () => {\n          if (resolve) {\n            send({error: new Error('Resource completed before producing a value')});\n          }\n          params.abortSignal.removeEventListener('abort', onAbort);\n        },\n      });\n\n      return promise;\n    },\n  });\n}\n"],
  "mappings": "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",
  "names": ["takeUntilDestroyed", "destroyRef", "assertInInjectionContext", "inject", "DestroyRef", "destroyed$", "Observable", "observer", "unregisterFn", "onDestroy", "next", "bind", "source", "pipe", "takeUntil", "OutputFromObservableRef", "destroyed", "constructor", "subscribe", "callbackFn", "_RuntimeError", "ngDevMode", "subscription", "value", "unsubscribe", "outputFromObservable", "observable", "opts", "outputToObservable", "ref", "_getOutputDestroyRef", "complete", "v", "toObservable", "options", "injector", "Injector", "subject", "ReplaySubject", "watcher", "effect", "err", "untracked", "error", "manualCleanup", "get", "destroy", "asObservable", "toObservableMicrotask", "_microtaskEffect", "toSignal", "assertNotInReactiveContext", "requiresCleanup", "cleanupRef", "equal", "makeToSignalEqual", "state", "requireSync", "signal", "kind", "initialValue", "destroyUnregisterFn", "sub", "set", "rejectErrors", "computed", "current", "userEquality", "Object", "is", "a", "b", "pendingUntilEvent", "undefined", "taskService", "PendingTasks", "sourceObservable", "originalSubscriber", "removeTask", "add", "cleanedUp", "cleanupTask", "innerSubscription", "e", "rxResource", "resource", "loader", "stream", "params", "onAbort", "abortSignal", "addEventListener", "resolve", "promise", "Promise", "r", "send", "removeEventListener", "Error"]
}
